#! /usr/bin/python -tt
#
# Author: Satoru SATOH <ssato redhat.com>
# License: MIT
#
import anyconfig as A
import jinja2_cli.render as JR

import datetime
import glob
import logging
import optparse
import os.path
import os
import pprint
import random
import sys


# SEE configure.ac:
VERSION = "0.0.4"

LOG = logging.getLogger("docutils-exts-bootstrap")
LOG.setLevel(logging.INFO)
A.set_loglevel(logging.INFO)

TMPL_EXT = ".j2"


def sglob(files_pattern):
    return sorted(glob.glob(files_pattern))


def _to_relpath(path, destdir):
    """
    >>> _to_relpath("/a/b/c/d/e", "/a/b/c")
    'd/e'
    >>> _to_relpath("/a/b/c/d/e", "/a/b/c/")
    'd/e'
    >>> _to_relpath("/a/b/c/d/e", "/a/b/d")
    None
    """
    if not path.startswith(destdir):
        LOG.warn("The {} does not start with {}".format(path, destdir))
        return None

    return path.replace(destdir if destdir.endswith('/') else destdir + '/',
                        '')


def _tmpl_to_outpath(path, destdir, ext=TMPL_EXT):
    """
    >>> _tmpl_to_outpath('/a/b/c/d/e.rst.j2', '/a/b/c')
    'd/e.rst'
    """
    relpath = _to_relpath(path, destdir)
    if relpath is None:
        return None

    (fn, fext) = os.path.splitext(relpath)

    if fext != ext:
        LOG.warn("The {} does not match with expected extension, "
                 "{}".format(fext, ext))
        return None

    return fn


def _compile_template(tmpl_path, destdir, workdir, ctx={}, ext=TMPL_EXT,
                      force=False):
    """
    Compile given template file ``tmpl_path`` with given context ``ctx`` and
    dump into the file under ``workdir`` with template file path relative to
    ``destdir`` kept.

    :param tmpl_path: Template file path
    :param destdir: Template top dir to strip from ``tmpl_path``
    :param workdir: Working dir to save compiled results
    :param ctx: Context dictionary to instantiate given template
    """
    tmpl_path = os.path.abspath(tmpl_path)
    outpath = os.path.join(workdir, _tmpl_to_outpath(tmpl_path, destdir, ext))
    tpaths = [os.path.dirname(tmpl_path), os.curdir]

    if os.path.exists(outpath):
        if force:
            os.rename(dst, dst + '~')
        else:
            LOG.info("{} already exists. Skip it...".format(outpath))
            return

    LOG.debug("Compile the template {} to {}".format(tmpl_path, outpath))
    JR.renderto(_to_relpath(tmpl_path, destdir), ctx, tpaths, outpath)


def _setup_file(path, destdir, workdir, ctx, ext=TMPL_EXT, force=False):
    if path.endswith(ext):
        _compile_template(path, destdir, workdir, ctx, ext, force)
    else:
        relpath = _to_relpath(path, destdir)
        reldir = os.path.dirname(relpath)

        dst = os.path.join(workdir, relpath)

        if os.path.exists(dst):
            if force:
                os.rename(dst, dst + '~')
            else:
                LOG.info("{} already exists. Skip it...".format(dst))
                return

        dstdir = os.path.dirname(dst)
        if not os.path.exists(dstdir):
            os.makedirs(dstdir)

        LOG.debug("Make a symlink from {} to {} (relpath)".format(path, relpath))
        os.symlink(path, dst)


def setup_files(destdir, workdir, ctx, ext=TMPL_EXT, force=False):
    """
    """
    for dirpath, dirnames, filenames in os.walk(destdir):
        for dn in dirnames:
            d = os.path.join(workdir, _to_relpath(os.path.join(dirpath, dn),
                                                  destdir))
            if not os.path.exists(d):
                os.makedirs(d)

        for fn in filenames:
            _setup_file(os.path.join(dirpath, fn), destdir, workdir, ctx, ext,
                        force)


USAGE = "%prog [Options...] DOC_NAME TEMPLATES_DIR"
TODAY = datetime.datetime.now().strftime("%Y%m%d")
DEFAULTS = dict(ctx=None, debug=False, force=False,
                workdir="/tmp/{}.{}".format(TODAY, random.randint(1, 10)))


def option_parser(usage=USAGE, defaults=DEFAULTS):
    """
    Make up an option and arguments parser.

    :param defaults: Default option values
    :param usage: Usage text
    """
    parser = optparse.OptionParser(usage, version="%%prog %s" % VERSION)
    parser.set_defaults(**defaults)
    parser.add_option("-w", "--workdir", help="Working dir [%default]")
    parser.add_option("-f", "--force", action="store_true",
                      help="Force overwrite outputs even if they exist")
    parser.add_option("-C", "--ctx",
                      help="Specify file path to provides context data "
                           "to instantiate templates. The file must be"
                           "in YAML format")
    parser.add_option("-D", "--debug", action="store_true",
                      help="Debug (verbose) mode")
    return parser


def main(argv=sys.argv):
    """
    :param argv: Argument list to parse [sys.argv]
    """
    parser = option_parser()
    (options, args) = parser.parse_args(argv[1:])

    if not args or len(args) < 2:
        parser.print_usage()
        sys.exit(-1)

    doc_name = args[0]
    tmpldir = args[1]

    if options.debug:
        LOG.setLevel(logging.DEBUG)
        A.set_loglevel(logging.DEBUG)

    if not options.workdir:
        options.workdir = os.path.join(os.curdir, "workdir-" + options.type)

    if options.ctx:
        if '~' in options.ctx:
            options.ctx = os.path.expanduser(options.ctx)

        ctx = A.load(options.ctx)
    else:
        ctx = {}

    ctx["doc_name"] = doc_name
    ctx["doc_revision"] = "{}.1".format(TODAY)
    LOG.debug("ctx:\n" + pprint.pformat(ctx))

    if not os.path.exists(options.workdir):
        os.makedirs(options.workdir)

    setup_files(tmpldir, options.workdir, ctx, TMPL_EXT, options.force)
    LOG.info("Bootstrap done. Results in: " + options.workdir)


if __name__ == '__main__':
    main(sys.argv)

# vim:sw=4:ts=4:et:
